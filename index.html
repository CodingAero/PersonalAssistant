<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Personal Assistant</title>
    <link rel="stylesheet" type="text/css" href="https://CodingAero.github.io/style.css">
    <style>
        pre {
            background-color: #f4f4f4;
            border-radius: 4px;
            padding: 1rem;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
        }
        code {
            color: #333;
        }
        .center {
            display: block;
            margin-left: auto;
            margin-right: auto;
            width: 50%;
        }
    </style>
</head>

<body>
    <header>
        <nav class="container">
            <div class="logo"></div>
            <div class="nav-links">
                <a href="https://codingaero.github.io/">Home</a>
                <a href="#overview">Overview</a>
                <a href="#code">Code</a>
            </div>
        </nav>
    </header>

    <section class="hero">
        <div class="container">
            <h1>Personal Assistant</h1>
            <p>Python Project</p>
        </div>
    </section>

    <section id="overview">
        <div class="container">
            <h2 class="section-title">Overview</h2>
            <div class="experience">
                <p>
                    The goal of this personal assistant, affectionately known as  "Winston", is to send a daily email with relevant information
                    such as upcoming birthdays/anniversaries and trash/recycling days. This page provides an overview of the code but may at times
                    become outdated or skip over newer functionality. The latest code can be found <a href="https://github.com/CodingAero/PersonalAssistant">on the associated GitHub page</a>.
                    <br>
                    <br>
                    The script can be run using the following command:
                </p>
                <pre><code>
                    python personalAssistant.py
                </pre></code>
                <p>
                    <br>
                    <br>
                    I run mine using a cron job set for every morning at 6 AM. The resulting email looks something like this:
                    <br>
                    <br>
                </p>
                <img src="images/example_email.png" alt="example email" class="center">
            </div>
        </div>
    </section>

    <section id="code">
        <div class="container">
            <h2 class="section-title">personalAssistant.py</h2>
            <div class="experience">
                <p>
                    This is the main file we call to run the personal assistant script. All primary supporting functions are called from here.
                    <br>
                    <br>
                </p>
                <pre><code>
                    ##########################################################################
                    # File: personalAssistant.py
                    # Brief description: This file is meant to provide a daily email
                    #       in order to stay informed on various topics.
                    # Author: Michael J. Smith
                    ##########################################################################
                    
                    # Import statements
                    import func_composeMessage as cm
                    import func_email as em
                    import func_general as g
                    import func_statusLogging as sl
                    import json
                    import os
                    from datetime import datetime
                    
                    ##########################################################################
                    # Configuration
                    ##########################################################################
                    
                    config_path = g.configPath(True)
                    
                    # Note: Find the configuration items in config.json
                    with open(config_path) as file:
                        cnfg = json.loads(file.read())
                    
                        # Specify the platform from which the script is being run.
                        # Gmail access requires the use of an 'App Password'
                        # Passwords have been generated for the following platforms:
                        # 'iPhone','iPad','Mac','WindowsPhone','WindowsComp','Rasp'
                        platform  = cnfg['platform']
                    
                        # Toggle to True if you prefer the email is printed within the terminal
                        # window rather than being sent as an actual email.
                        emailInTerminal = cnfg['emailInTerminal'] == "True" # Bool conversion
                    
                        # Toggle print messages
                        verbose = cnfg['verbose'] == "True" # Bool conversion
                    
                        # File path to the log file
                        logFile = cnfg['logFile']
                    
                        # This specifies how the assistant will refer to you
                        yourName = cnfg['yourName']
                        
                        # This specifies how the assistant will refer to theirself
                        assistantName = cnfg['assistantName']
                    
                    ##########################################################################
                    # Program logic
                    ##########################################################################
                    
                    start_time = datetime.now()
                    
                    #Initialize log file
                    sl.intializeLog()
                    
                    # Initialize the correspondence message
                    msg = cm.intializeMessage(verbose)
                    
                    # Expand the correspondence message
                    msg = cm.eventMessage(msg, verbose)
                    msg = cm.creditCardMessage(msg, verbose)
                    msg = cm.trashRecyclingMessage(msg, verbose)
                    
                    # Clos the correspondence message
                    msg = cm.valedictionMessage(msg, verbose)
                    
                    # Print email in terminal vs send email
                    sl.infoMessage("Final correspondence message\n{0}".format(msg),verbose)
                    if emailInTerminal:
                        print(msg)
                    else:
                        em.reportFindings(msg, verbose)
                    
                    # Print a final message to screen
                    end_time = datetime.now()
                    execution_time = end_time - start_time
                    sl.infoMessage("Successful program execution in {0} second(s).".format(execution_time.total_seconds()),verbose)
                </code></pre>
            </div>
        </div>
    </section>

    <section>
        <div class="container">
            <h2 class="section-title">config.json</h2>
            <div class="experience">
                <p>
                    This file contains the configuration and can be used to quickly tailor the email to fit different use cases. Here are brief 
                    descriptions of the various configuration items below.
                    <br>
                    <br>
                    <b>platform:</b> This helps the program identify which app password to use when sending the email. This could be determined by
                    <br>
                    <br>
                    <b>emailInTerminal:</b> This is a boolean controlling whether the email is printed in terminal (i.e. 'True') or sent as an email 
                    (i.e. 'False').
                    <br>
                    <br>
                    <b>verbose:</b> This is a boolean allowing for extra logging (i.e. 'True') or a minimal amount (i.e. 'False').
                    <br>
                    <br>
                    <b>logFile:</b> This is the file path to the log file.
                    <br>
                    <br>
                    <b>countriesFile:</b> This is the file path to the countries file.
                    <br>
                    <br>
                    <b>datesFile:</b> This is the file path to the dates file.
                    <br>
                    <br>
                    <b>quotesFile:</b> This is the file path to the quotes file.
                    <br>
                    <br>
                    <b>statesFile:</b> This is the file path to the states file.
                    <br>
                    <br>
                    <b>wordsFile:</b> This is the file path to the words file.
                    <br>
                    <br>
                    <b>yourName:</b> How you will be addressed in the resulting email.
                    <br>
                    <br>
                    <b>assistantName:</b> How the personal assistant will refer to itself.
                    <br>
                    <br>
                    <b>from_email:</b> Where the final email is sent from. (e.g. the "From" field) I created a unique email for my personal assistant's 
                    communication.
                    <br>
                    <br>
                    <b>to_email:</b> An email address where the final email is sent. (e.g. the "To" field)
                    <br>
                    <br>
                    <b>subject:</b> This is the subject line for the email but can also be set to 'default' to use a standard date stamped subject line.
                    <br>
                    <br>
                    <b>eventOutlook:</b> This is how far out (in days) you want to be alerted for upcoming events.
                    <br>
                    <br>
                    <b>lastDeparture:</b> This tracks whether the last departure location was a state or country thereby allowing the program to list the 
                    previous arrival location as the next departure location for the fake travel your personal assistant is doing. This might make more 
                    sense as you learn more below about the purpose of this fake travel.
                    <br>
                    <br>
                    <b>lastStateId:</b> This is the index of the last used state in the fake travel schedule.
                    <br>
                    <br>
                    <b>lastCountryId:</b> This is the index of the last used country in the fake travel schedule.
                    <br>
                    <br>
                    <b>lastWordId:</b> This is the index of the last used word for the 'Word of the Day' rotation.
                    <br>
                    <br>
                    <b>lastQuoteId:</b> This is the index of the last used quote for the 'Quote of the Day' rotation.
                    <br>
                    <br>
                    * Please note that it may be beneficial to store the files above outside the local git repo for privacy and convenience reasons.
                    <br>
                    <br>
                </p>
                <pre><code>
                    {
                        "platform": "Mac",
                        "emailInTerminal": "True",
                        "verbose": "False",
                        "logFile": "log.txt",
                        "countriesFile": "./data/data_countries.json",
                        "datesFile": "./data/data_dates.json",
                        "quotesFile": "./data/data_quotes.json",
                        "statesFile": "./data/data_states.json",
                        "wordsFile": "./data/data_words.json",
                        "yourName": "Smith",
                        "assistantName": "Winston",
                        "from_email": "assistant@gmail.com",
                        "to_email": "you@gmail.com",
                        "subject": "default",
                        "eventOutlook": "14",
                        "lastDeparture": "country",
                        "lastStateId": "0",
                        "lastCountryId": "0",
                        "lastWordId": "0",
                        "lastQuoteId": "0"
                    }
                </code></pre>
            </div>
        </div>
    </section>

    <section>
        <div class="container">
            <h2 class="section-title">func_general.py</h2>
            <div class="experience">
                <p>
                    This file is helpful in identifying configuration and password files I intend to actually use (i.e. outside of my GitHub repository 
                    with real information) on various operating systems. This saves me a significant amount of time when making updates and having to pull  
                    those changes back to various computing environments.
                    <br>
                    <br>
                </p>
                <pre><code>
                    import json
                    import os

                    def configPath(verbose=False):
                        '''
                        Provide the configuration file path to keep real data out of the github
                        repository and prevent constant updates for various environments.

                        Input:
                            n/a
                        Output:
                            config_path (str): File path to the configuration file
                        '''

                        configs = {
                            'mac':      '/Users/smith/local_config/personal_assistant.json',
                            'ubuntu':   '/home/smith/Documents/Code/local_config/personal_assistant/personal_assistant.json',
                            'default':  'config.json'
                        }

                        config_path = ''

                        for c in configs.keys():
                            if os.path.exists(configs[c]):
                                config_path = configs[c]
                                if verbose: print("\n\n* Using '{0}' config\n\n".format(str(c)))
                                break

                        if config_path == '':
                            if verbose: print("Unable to locate a file containing your configuration.")
                            exit()

                        return config_path

                    def get_pass(platform,verbose):
                        '''
                        Send correspondence via email

                        Input:
                            platform (str): Platform the program is running on
                            verbose (bool): Print additional terminal messages
                        Output:
                            pw (str): Gmail password for the requested platform
                        '''

                        configs = {
                            'mac':      '/Users/smith/local_config/email.json',
                            'ubuntu':   '/home/smith/Documents/Code/local_config/email.json',
                            'default':  'protectedInfo.json'
                        }

                        config_path = ''

                        for c in configs.keys():
                            if os.path.exists(configs[c]):
                                config_path = configs[c]
                                break

                        if config_path == '':
                            if verbose: print("Unable to locate a file containing your email password.")
                            exit()

                        pw = ''
                        with open(config_path, 'r') as file:
                            pInfo = json.loads(file.read())
                            pw = pInfo['gmailPassword'][platform]
                        return pw
                </code></pre>
            </div>
        </div>
    </section>

    <section>
        <div class="container">
            <h2 class="section-title">protectedInfo.json</h2>
            <div class="experience">
                <p>
                    When sending the email, you cannot simply use your email and password for a Gmail account. Instead you need to use app passwords 
                    which at the time of this publication is <a href="https://support.google.com/mail/answer/185833?hl=en#">discussed here</a>. For 
                    privacy reasons, I am not listing real passwords below.
                    <br>
                    <br>
                </p>
                <pre><code>
                    {
                        "gmailPassword": {
                            "iPhone": "fakePassword",
                            "iPad": "fakePassword",
                            "Mac": "fakePassword",
                            "WindowsPhone": "fakePassword",
                            "WindowsComp": "fakePassword",
                            "Rasp": "fakePassword"
                        }
                    }
                </code></pre>
            </div>
        </div>
    </section>

    <section>
        <div class="container">
            <h2 class="section-title">func_composeMessage.py</h2>
            <div class="experience">
                <p>
                    This is where the email's body text is built out. As more functions are created and the email grows in terms of capabilities, this 
                    file will need to be further broken out. Today, the email's text covers topics like upcoming events, trash day reminders, word add 
                    quote of the day, as well as a fake travel route to reinforce knowledge on states and countries and their corresponding capitals.
                    <br>
                    <br>
                </p>
                <pre><code>
                    # Import statements
                    import datetime as datetime
                    import func_general as g
                    import func_statusLogging as sl
                    import json

                    ##########################################################################
                    # Configuration
                    ##########################################################################

                    config_path = g.configPath()

                    with open(config_path) as file:
                        cnfg = json.loads(file.read())
                        yourName = cnfg['yourName']
                        assistantName = cnfg['assistantName']
                        eventOutlook = int(cnfg['eventOutlook'])
                        countriesFile = cnfg['countriesFile']
                        datesFile = cnfg['datesFile']
                        quotesFile = cnfg['quotesFile']
                        statesFile = cnfg['statesFile']
                        wordsFile = cnfg['wordsFile']

                    ##########################################################################
                    # Functions
                    ##########################################################################

                    def intializeMessage(verbose):
                        '''
                        Starts the correspondence message string

                        Input:
                            verbose (bool): Print additional terminal messages
                        Output:
                            msg (str): Text forming the body of the email correspondence
                        '''

                        if verbose: sl.progressMessage("Starting the 'intializeMessage' function.",verbose)
                        
                        msg = "{0},\n\n".format(yourName) + \
                            "Let me catch you up on some relevant information for today."

                        return str(msg)

                    def eventMessage(msg,verbose):
                        '''
                        Appends upcoming event information to the correspondence message

                        Input:
                            msg (str): Text forming the body of the email correspondence
                            verbose (bool): Print additional terminal messages
                        Output:
                            msg (str): Text forming the body of the email correspondence
                        '''

                        if verbose: sl.progressMessage("Starting the 'eventMessage' function.",verbose)
                        
                        # Configuration
                        projection = eventOutlook

                        # Define today
                        today = datetime.datetime.now().replace(hour = 0, minute = 0, second = 0, microsecond = 0)

                        # Add to message
                        msg = (msg + '\n\n' + 'Birthdays and Anniversaries:')

                        # Read the JSON data from the file
                        with open(datesFile, "r", encoding="utf-8") as file_handle:
                            data = json.load(file_handle)

                        # Create an empty dictionary for days until celebration
                        days_until = {}
                        for i in range(projection + 1):
                            days_until[str(i)] = []

                        # For each date entry
                        for event in data['data']:
                            # Skip the entry if skip is 'yes'
                            if event['skip'] == "no":
                                # For entries with enough information (must include a month)
                                if (event['month'] != ""):
                                    event_month = int(event['month'])
                                    # Events missing a 'day' have the day default to 1 and the message will indicate an unknown day
                                    if (event['day'] != ""):
                                        event_day = int(event['day'])
                                        missing_day = False
                                    else:
                                        event_day = int(1)
                                        missing_day = True
                                    # Events missing a 'year' do not display
                                    if (event['year'] != ""):
                                        event_year = int(event['year'])
                                        missing_year = False
                                    else:
                                        event_year = int(today.year)
                                        missing_year = True
                                    # Define event date as day of the birthday or anniversary
                                    event_date = datetime.datetime(event_year, event_month, event_day)
                                    # This event should celebrate anniversaries
                                    if event_month != 1:
                                        year_11m_out = event_year + 1
                                        month_11m_out = event_month - 1
                                        if event_day > 28:
                                            day_11m_out = 28
                                        else:
                                            day_11m_out = event_day
                                    else:
                                        year_11m_out = event_year
                                        month_11m_out = 12
                                        if event_day > 28:
                                            day_11m_out = 28
                                        else:
                                            day_11m_out = event_day
                                    if ((today - datetime.datetime(year_11m_out, month_11m_out, day_11m_out)).days > 0) or missing_year:
                                        monthiversary = False
                                        # Define reference date as upcoming day when a celebration would occur
                                        reference_date = datetime.datetime(int(today.year), event_month, event_day)
                                        # Account for events at the start of the following year
                                        if (reference_date - today).days < 0:
                                            reference_date = datetime.datetime(int(today.year)+1, event_month, event_day)
                                    # This event should celebrate monthiversaries
                                    else:
                                        monthiversary = True
                                        for i in range(12):
                                            incremented_month = event_month + i
                                            incremented_year = event_year
                                            if incremented_month > 12:
                                                incremented_month -= 12
                                                incremented_year += 1
                                            # Potentially the 31st day of the month
                                            try:
                                                if (today - datetime.datetime(incremented_year, incremented_month, event_day)).days > 0:
                                                    reference_date = datetime.datetime(incremented_year, incremented_month+1, event_day)
                                                    month_count = i + 1
                                            except:
                                                # Potentially the 30th day of the month
                                                try:
                                                    if (today - datetime.datetime(incremented_year, incremented_month, event_day-1)).days > 0:
                                                        reference_date = datetime.datetime(incremented_year, incremented_month+1, event_day-1)
                                                        month_count = i + 1
                                                except:
                                                    # Potentially the 29th day of the month
                                                    try:
                                                        if (today - datetime.datetime(incremented_year, incremented_month, event_day-2)).days > 0:
                                                            reference_date = datetime.datetime(incremented_year, incremented_month+1, event_day-2)
                                                            month_count = i + 1
                                                    except:
                                                        # Potentially the 28th day of the month
                                                        try:
                                                            if (today - datetime.datetime(incremented_year, incremented_month, event_day-3)).days > 0:
                                                                reference_date = datetime.datetime(incremented_year, incremented_month+1, event_day-3)
                                                                month_count = i + 1
                                                        except:
                                                            print('Error: Having some trouble resolving the monthiversary.')
                                        
                                    days_remaining = (reference_date - today).days
                                    if days_remaining <= projection:
                                        years = reference_date.year - event_date.year
                                        # Directly appending did not work for a dictionary so we rebuild entry
                                        temp_list = []
                                        for e in days_until[str(days_remaining)]:
                                            temp_list.append(e)
                                        new_event = str(event['name']) + "."
                                        if missing_year == False and not monthiversary:
                                            new_event += " (" + str(years) + ")"
                                        if monthiversary:
                                            new_event += " (" + str(month_count) + " months)"
                                        if missing_day == True:
                                            new_event += " [Exact day is unknown]"
                                        temp_list.append(new_event)
                                        days_until[str(days_remaining)] = temp_list

                        for key in days_until:
                            if key == '0':
                                for i in days_until[key]:
                                    # print("Today is " + str(i))
                                    msg = (msg + '\n' + 'Today is ' + str(i))
                            elif key == '1':
                                for i in days_until[key]:
                                    # print("Tomorrow is " + str(i))
                                    msg = (msg + '\n' + 'Tomorrow is ' + str(i))
                            else:
                                for i in days_until[key]:
                                    date = (today + datetime.timedelta(days=int(key))).strftime("%A, %B %d")
                                    # print("In " + str(key) + " days, on " + str(date) + ", it will be " + str(i))
                                    msg = (msg + '\n' + 'In ' + str(key) + ' days, on ' + str(date) + ', it will be ' + str(i))

                        return msg

                    def creditCardMessage(msg,verbose):
                        '''
                        Appends upcoming credit card due date information to the correspondence message

                        Input:
                            msg (str): Text forming the body of the email correspondence
                            verbose (bool): Print additional terminal messages
                        Output:
                            msg (str): Text forming the body of the email correspondence
                        '''

                        if verbose: sl.progressMessage("Starting the 'creditCardMessage' function.",verbose)

                        now = datetime.datetime.now()
                        begin_alert = 5 # Day of the month, inclusive
                        end_alert = 12 # Day of the month, inclusive
                        
                        if (int(now.strftime("%d")) >= begin_alert) and (int(now.strftime("%d")) <= end_alert):
                            msg = (msg + '\n\n' + 'Credit Card:' + '\n' + 'Time to pay your credit card.')

                        return msg

                    def trashRecyclingMessage(msg,verbose):
                        '''
                        Appends upcoming trash and recycling day information to the correspondence message

                        Input:
                            msg (str): Text forming the body of the email correspondence
                            verbose (bool): Print additional terminal messages
                        Output:
                            msg (str): Text forming the body of the email correspondence
                        '''

                        if verbose: sl.progressMessage("Starting the 'trashRecyclingMessage' function.",verbose)

                        now = datetime.datetime.now()
                        
                        if (now.isocalendar()[1] % 2) > 0: # Alternating recycling weeks
                            if now.weekday() == 0: # Monday
                                msg = (msg + '\n\n' + 'Trash/Recycling:' + '\n' + 'Tomorrow is trash day.')
                            elif now.weekday() == 1: # Tuesday
                                msg = (msg + '\n\n' + 'Trash/Recycling:' + '\n' + 'It is trash day.')
                        else:
                            if now.weekday() == 0: # Monday
                                msg = (msg + '\n\n' + 'Trash/Recycling:' + '\n' + 'Tomorrow is a trash and recycling day.')
                            elif now.weekday() == 1: # Tuesday
                                msg = (msg + '\n\n' + 'Trash/Recycling:' + '\n' + 'It is a trash and recycling day.')

                        return msg

                    def valedictionMessage(msg,verbose):
                        '''
                        Closes the correspondence message

                        Input:
                            msg (str): Text forming the body of the email correspondence
                            verbose (bool): Print additional terminal messages
                        Output:
                            msg (str): Text forming the body of the email correspondence
                        '''

                        if verbose: sl.progressMessage("Starting the 'valedictionMessage' function.",verbose)

                        departure,destination = getStateCountry(verbose)

                        msg_addition = "Sincerely, {0}\n\n".format(assistantName) + \
                            "In route from {0} to {1}.\n\n".format(departure, destination) + \
                            "Word of the day:\n" + \
                            getWord(verbose) + "\n\n" + \
                            "Quote of the day:\n" + \
                            getQuote(verbose)
                        msg = msg + "\n\n" + msg_addition

                        return msg

                    def getStateCountry(verbose):
                        '''
                        Provide fake travel information to reinforce geography knowledge. The previous
                        day's destination becomes the current days departure location.

                        Input:
                            verbose (bool): Print additional terminal messages
                        Output:
                            departure (str): State/Country and capital text to list in valediction
                            destination (str): State/Country and capital text to list in valediction
                        '''

                        if verbose: sl.progressMessage("Starting the 'getStateCountry' function.",verbose)

                        departure = ""
                        destination = ""

                        with open(config_path) as confFile:
                            conf = json.loads(confFile.read())

                        lastDeparture = conf['lastDeparture']
                        lastStateId = int(conf['lastStateId'])
                        lastCountryId = int(conf['lastCountryId'])
                        
                        if lastDeparture == "state":
                            departureId = lastCountryId
                            conf['lastDeparture'] = "country"
                            conf['lastCountryId'] = str(departureId)
                        else:
                            departureId = lastStateId
                            conf['lastDeparture'] = "state"
                            conf['lastStateId'] = str(departureId)
                        
                        with open(statesFile) as stateFile:
                            st = json.loads(stateFile.read())
                            if lastDeparture == "state":
                                searching = True
                                destinationId = lastStateId + 1
                                while searching:
                                    while destinationId >= len(st["states"]):
                                        destinationId -= len(st["states"])
                                    if st["states"][destinationId]["skip"] == "no":
                                        searching = False
                                    else:
                                        destinationId += 1
                                conf['lastStateId'] = str(destinationId)
                                destination = "{0}, {1}".format(st["states"][destinationId]["capital"],st["states"][destinationId]["state"])
                            else:
                                departure = "{0}, {1}".format(st["states"][departureId]["capital"],st["states"][departureId]["state"])
                                
                        with open(countriesFile) as countryFile:
                            cnrt = json.loads(countryFile.read())
                            if lastDeparture == "state":
                                departure = "{0}, {1}".format(cnrt["countries"][departureId]["capital"],cnrt["countries"][departureId]["short-form name"])
                            else:
                                searching = True
                                destinationId = lastCountryId + 1
                                while searching:
                                    while destinationId >= len(cnrt["countries"]):
                                        destinationId -= len(cnrt["countries"])
                                    if cnrt["countries"][destinationId]["skip"] == "no":
                                        searching = False
                                    else:
                                        destinationId += 1
                                conf['lastCountryId'] = str(destinationId)
                                destination = "{0}, {1}".format(cnrt["countries"][destinationId]["capital"],cnrt["countries"][destinationId]["short-form name"])
                        
                        with open(config_path, 'w') as confFile:
                            json.dump(conf, confFile, indent=4)
                        
                        return departure,destination

                    def getWord(verbose):
                        '''
                        Determines the next word of the day and provides a string to place
                        into the daily correspondence email.

                        Input:
                            verbose (bool): Print additional terminal messages
                        Output:
                            wotd (str): Word of the day text
                        '''

                        if verbose: sl.progressMessage("Starting the 'getWord' function.",verbose)

                        wotd = ""

                        with open(config_path) as confFile:
                            conf = json.loads(confFile.read())

                        lastWordId = int(conf['lastWordId'])
                                
                        with open(wordsFile) as wrdFile:
                            wrd = json.loads(wrdFile.read())

                            searching = True
                            wordId = lastWordId + 1
                            while searching:
                                while wordId >= len(wrd["words"]):
                                    wordId -= len(wrd["words"])
                                if wrd["words"][wordId]["skip"] == "no":
                                    searching = False
                                else:
                                    wordId += 1
                            conf['lastWordId'] = str(wordId)
                            wotd = "{0} ({1}): {2}\nSentence: \"{3}\"".format(wrd["words"][wordId]["word"],wrd["words"][wordId]["part of speech"],wrd["words"][wordId]["definition"],wrd["words"][wordId]["sentence"])
                        
                        with open(config_path, 'w') as confFile:
                            json.dump(conf, confFile, indent=4)
                        
                        return wotd

                    def getQuote(verbose):
                        '''
                        Determines the next quote of the day and provides a string to place
                        into the daily correspondence email.

                        Input:
                            verbose (bool): Print additional terminal messages
                        Output:
                            qotd (str): Quote of the day text
                        '''

                        if verbose: sl.progressMessage("Starting the 'getQuote' function.",verbose)

                        qotd = ""

                        with open(config_path) as confFile:
                            conf = json.loads(confFile.read())

                        lastQuoteId = int(conf['lastQuoteId'])
                                
                        with open(quotesFile) as qtFile:
                            qt = json.loads(qtFile.read())

                            searching = True
                            quoteId = lastQuoteId + 1
                            while searching:
                                while quoteId >= len(qt["quotes"]):
                                    quoteId -= len(qt["quotes"])
                                if qt["quotes"][quoteId]["skip"] == "no":
                                    searching = False
                                else:
                                    quoteId += 1
                            conf['lastQuoteId'] = str(quoteId)
                            qotd = "{0} ({1})".format(qt["quotes"][quoteId]["quote"],qt["quotes"][quoteId]["author"])
                        
                        with open(config_path, 'w') as confFile:
                            json.dump(conf, confFile, indent=4)
                        
                        return qotd
                </code></pre>
            </div>
        </div>
    </section>

    <section>
        <div class="container">
            <h2 class="section-title">func_email.py</h2>
            <div class="experience">
                <p>
                    This file is where the email is actually sent.
                    <br>
                    <br>
                </p>
                <pre><code>
                    # Import statements
                    import datetime as datetime
                    import func_general as g
                    import func_statusLogging as sl
                    import json
                    import smtplib

                    ##########################################################################
                    # Configuration
                    ##########################################################################

                    config_path = g.configPath()

                    with open(config_path) as file:
                        cnfg = json.loads(file.read())
                        platform = cnfg['platform']
                        emailInTerminal = cnfg['emailInTerminal'] == "True" # Bool conversion
                        verbose = cnfg['verbose'] == "True" # Bool conversion
                        logFile = cnfg['logFile']
                        assistantName = cnfg['assistantName']
                        from_email = cnfg['from_email']
                        to_email = cnfg['to_email']
                        subject = cnfg['subject']

                    ##########################################################################
                    # Functions
                    ##########################################################################

                    def reportFindings(msg,verbose):
                        '''
                        Send correspondence via email

                        Input:
                            msg (str): Text forming the body of the email correspondence
                            verbose (bool): Print additional terminal messages
                        Output:
                            n/a
                        '''

                        if verbose: sl.progressMessage("Starting the 'reportFindings' function.",verbose)

                        subject = cnfg['subject']

                        if subject == "default":
                            subject = "Daily Correspondence ({0})".format(datetime.datetime.now().strftime("%Y-%m-%d"))

                        smtpserver = smtplib.SMTP("smtp.gmail.com",587)
                        smtpserver.ehlo()
                        smtpserver.starttls()
                        smtpserver.ehlo
                        smtpserver.login(from_email,g.get_pass(platform,verbose))
                        header = "To: " + to_email + "\nFrom: " + from_email
                        header = header + "\nSubject: " + subject + "\n"
                        URGENT_MESSAGE = header + "\n" + msg
                        smtpserver.sendmail(from_email,to_email,URGENT_MESSAGE)
                        smtpserver.close()

                        return
                </code></pre>
            </div>
        </div>
    </section>

    <section>
        <div class="container">
            <h2 class="section-title">func_statusLogging.py</h2>
            <div class="experience">
                <p>
                    This file is used to standardize logging messages into messages for errors, information, and progress. It also creates a log file 
                    or clear the existing log file.
                    <br>
                    <br>
                </p>
                <pre><code>
                    # Import statements
                    import func_general as g
                    import json
                    from datetime import datetime

                    ##########################################################################
                    # Configuration
                    ##########################################################################

                    config_path = g.configPath()

                    with open(config_path) as file:
                        cnfg = json.loads(file.read())
                        logFile = cnfg['logFile']

                    ##########################################################################
                    # Functions
                    ##########################################################################

                    def intializeLog():
                        """
                        Creates a new log file or clears the contents of the existing log file.
                        
                        Input:
                            n/a
                        Output:
                            n/a
                        """

                        try:
                            with open(logFile, 'w') as f:
                                f.write("Program initialized: {0}".format(datetime.now()))
                        except Exception as e:
                            errorMessage(f"An error occurred initializing the log file: {e}")
                        
                        return

                    def errorMessage(txt,verbose):
                        '''
                        Prints an Error message in the log file

                        Input:
                            msg (str): Error message text
                            verbose (bool): Print additional terminal messages
                        Output:
                            n/a
                        '''

                        if verbose: print("\nERROR: {0}".format(txt))

                        with open(logFile, 'a') as f:
                            f.write("\nERROR: {0}".format(txt))

                        return

                    def infoMessage(txt,verbose):
                        '''
                        Prints an Info message in the log file

                        Input:
                            txt (str): Info message text
                            verbose (bool): Print additional terminal messages
                        Output:
                            n/a
                        '''

                        try:
                            with open(logFile, 'a') as f:
                                f.write("\nINFO: {0}".format(txt))
                        except Exception as e:
                            errorMessage(f"An error occurred logging an info message: {e}")
                        
                        return

                    def progressMessage(txt,verbose):
                        '''
                        Prints an Info message in the log file

                        Input:
                            txt (str): Info message text
                            verbose (bool): Print additional terminal messages
                        Output:
                            n/a
                        '''

                        if verbose:
                            try:
                                with open(logFile, 'a') as f:
                                    f.write("\nProgress: {0}".format(txt))
                            except Exception as e:
                                errorMessage(f"An error occurred logging a progress message: {e}")
                        
                        return
                </code></pre>
            </div>
        </div>
    </section>

    <section>
        <div class="container">
            <h2 class="section-title">data_dates.json</h2>
            <div class="experience">
                <p>
                    These dates are stored as a JSON file and form the text for upcoming events. Any date within the 'eventOutlook' window specified
                    in the configuration file will be listed in the resulting email.
                    <br>
                    <br>
                </p>
                <pre><code>
                    {
                        "data": [
                            {
                                "name": "Test Date 1",
                                "month": "01",
                                "day": "01",
                                "year": "1990",
                                "skip": "no"
                            },

                            [shortened for readability]

                            {
                                "name": "Test Date 2",
                                "month": "12",
                                "day": "31",
                                "year": "2010",
                                "skip": "yes"
                            }
                        ]
                    }
                </code></pre>
            </div>
        </div>
    </section>

    <section>
        <div class="container">
            <h2 class="section-title">data_quotes.json</h2>
            <div class="experience">
                <p>
                    The quotes below are stored as a JSON file and are appended to the end of the email as a 'Quote of the Day'. The index of the last 
                    'Quote of the Day' is stored in the configuration file and the next quote is pulled sequencially.
                    <br>
                    <br>
                </p>
                <pre><code>
                    {
                        "quotes": [
                            {
                                "quote": "Do what you can, with what you have, where you are.",
                                "author": "Theodore Roosevelt",
                                "skip": "no"
                            },

                            [shortened for readability]

                            {
                                "quote": "Keep your eyes on the stars, and your feet on the ground.",
                                "author": "Theodore Roosevelt",
                                "skip": "no"
                            }
                        ]
                    }
                </code></pre>
            </div>
        </div>
    </section>

    <section>
        <div class="container">
            <h2 class="section-title">data_countries.json</h2>
            <div class="experience">
                <p>
                    The countries below are stored as a JSON file and are appended to the end of the email mimicking a fake trip between a US state capital
                    and a country's capital. The purpose of adding this false information is to refresh my memory of capitals as well as prompt potential
                    internet searches to learn more about places around the world. The index of the last country used is stored in the configuration file 
                    and the next country is pulled sequencially. The destination of the previous fake trip also becomes the departure location for the next 
                    trip by tracking in the configuration file whether a country of state was the last departure location.
                    <br>
                    <br>
                </p>
                <pre><code>
                    {
                        "countries": [
                            {
                                "short-form name": "Belgium",
                                "long-form name": "Kingdom of Belgium",
                                "capital": "Brussels",
                                "skip": "no"
                            },

                            [shortened for readability]

                            {
                                "short-form name": "Zimbabwe",
                                "long-form name": "Republic of Zimbabwe",
                                "capital": "Harare",
                                "skip": "no"
                            }
                        ]
                    }
                </code></pre>
            </div>
        </div>
    </section>

    <section>
        <div class="container">
            <h2 class="section-title">data_states.json</h2>
            <div class="experience">
                <p>
                    The states below are stored as a JSON file and are appended to the end of the email mimicking a fake trip between a US state capital
                    and a country's capital. The purpose of adding this false information is to refresh my memory of capitals as well as prompt potential
                    internet searches to learn more about places around the world. The index of the last state used is stored in the configuration file 
                    and the next state is pulled sequencially. The destination of the previous fake trip also becomes the departure location for the next 
                    trip by tracking in the configuration file whether a country of state was the last departure location.
                    <br>
                    <br>
                </p>
                <pre><code>
                    {
                        "states": [
                            {
                                "state": "Alabama",
                                "capital": "Montgomery",
                                "skip": "no"
                            },

                            [shortened for readability]

                            {
                                "state": "Wyoming",
                                "capital": "Cheyenne",
                                "skip": "no"
                            }
                        ]
                    }
                </code></pre>
            </div>
        </div>
    </section>

    <section>
        <div class="container">
            <h2 class="section-title">data_words.json</h2>
            <div class="experience">
                <p>
                    The words below are stored as a JSON file and are appended to the end of the email as a 'Word of the Day'. The index of the last 
                    'Word of the Day' is stored in the config file and the next word is pulled sequencially.
                    <br>
                    <br>
                </p>
                <pre><code>
                    {
                        "words": [
                            {
                                "word":"austere",
                                "part of speech": "adjective",
                                "definition": "severe or strict in manner, attitude, or appearance",
                                "sentence": "the cathedral is impressive in its austere simplicity",
                                "skip": "no"
                            },

                            [shortened for readability]

                            {
                                "word":"gregarious",
                                "part of speech": "adjective",
                                "definition": "(of a person) fond of company; sociable.",
                                "sentence": "he was a popular and gregarious man",
                                "skip": "no"
                            }
                        ]
                    }
                </code></pre>
            </div>
        </div>
    </section>

    <footer>
        <div class="container">
            <p>&copy; 2025 Michael Smith. All rights reserved.</p>
        </div>
    </footer>
</body>

</html>
